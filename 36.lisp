(defun reverse-num(num &optional (base 10))
	   (declare (type fixnum num base))
	   (loop
	      for n = num then (truncate (/ n base))
	      while (> n 0)
	      for i = (mod n base) then (+ (mod n base) (* base i))
	      finally (return i)))
(defun euler36()
	   (loop for i from 1 upto 1000000
	      if (and (/= (mod i 10) 0)(/= (mod i 2) 0) (= i (reverse-num i 10))(= i  (reverse-num i 2)))
	      sum i))
(defun euler36-2()
  (do ((n 1 (1+ n))(s 0)a b)
      ((= n 1000000) s)
    (declare (type fixnum n s))
    (if (and
	 (/= (mod n 10) 0)
	 (/= (mod n 2) 0)
	 (string= (setf a (write-to-string n)) (reverse a))
	 (string= (setf b (write-to-string n :base 2)) (reverse b)))
	(format t "~a " n))))
(defun reverse-num-2(num new-num base)
  (declare (type fixnum num new-num base))
  (if (> num 0)
      (reverse-num-2 (truncate (/ num base)) (+ (mod num base) (* base new-num)) base)
      new-num))
(time (euler36))